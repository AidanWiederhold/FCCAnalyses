#from snakemake.remote.XRootD import RemoteProvider as XRootDRemoteProvider
#XRootD = XRootDRemoteProvider(stay_on_remote=True)
from config import (
                    FCCeePhysicsPerformance_scripts,
                    list_to_constraints,
                    event_types,
                    decays_to_fnames,
                    decays,
                    snakemake_flags,
                    outputs,
                    logs,
                    benchmarks,
                    blacklister,
                    tuple_id_blacklist,
                    MC,
                    decay_model_to_fname,
                    analysis_scripts,
                    )

report: "b2snunu/workflow_report.rst"

with open("eos_cache.json") as inf:
    eos_cache = json.load(inf)

wildcard_constraints:
    event_type = list_to_constraints(list(event_types.keys())),
    decay_fname = list_to_constraints(decays_to_fnames(list(decays))),
    decay = list_to_constraints(list(decays)),
    decay_model = "(inclusive|signal)",
    tuple_id = "\d+",

rule all:
    input:
        expand(snakemake_flags+"{decay}_done", decay=decays),
        expand(outputs+"plots/mva/{decay}.png", decay=decays)
    output: snakemake_flags+"all"
    shell: "touch {output}"

rule decays:
    input: lambda wildcards: expand(snakemake_flags+"{{decay}}/{event_type}_done", event_type=list(event_types.keys())),
    output: snakemake_flags+"{decay}_done"
    shell: "touch {output}"

rule event_types:
    input: lambda wildcards: expand(snakemake_flags+"{{decay}}/{{event_type}}/{decay_model}", decay_model=event_types[wildcards.event_type])
    output: snakemake_flags+"{decay}/{event_type}_done"
    shell: "touch {output}"

rule decay_models:
    input: lambda wildcards: expand(outputs+"mva_cut/{{decay}}/{{event_type}}/{{decay_model}}/{tuple_id}.root", tuple_id=blacklister(range(len(eos_cache[wildcards.decay][wildcards.event_type][wildcards.decay_model]["expected_output"])), tuple_id_blacklist[wildcards.decay][wildcards.event_type][wildcards.decay_model]))
    output: temp(snakemake_flags+"{decay}/{event_type}/{decay_model}")
    shell: "touch {output}"

rule mva_cut:
    input: outputs+"stage1/{decay}/{event_type}/{decay_model}/{tuple_id}.root"
    output: outputs+"mva_cut/{decay}/{event_type}/{decay_model}/{tuple_id}.root"
    log: logs+"mva_cut/{decay}/{event_type}/{decay_model}/{tuple_id}.log"
    benchmark: benchmarks+"mva_cut/{decay}/{event_type}/{decay_model}/{tuple_id}.txt"
    shell: "python {analysis_scripts}/mva_cut.py --input {input} --output {output} --decay {wildcards.decay} &> {log}"

rule mva_plots:
    input:
        signal = lambda wildcards: expand(outputs+"stage1/{{decay}}/p8_ee_Zbb_ecm91/signal/{tuple_id}.root", tuple_id=blacklister(range(len(eos_cache[wildcards.decay]["p8_ee_Zbb_ecm91"]["signal"]["expected_output"])), tuple_id_blacklist[wildcards.decay]["p8_ee_Zbb_ecm91"]["signal"])),
        inclusive_bbbar = lambda wildcards: expand(outputs+"stage1/{{decay}}/p8_ee_Zbb_ecm91/inclusive/{tuple_id}.root", tuple_id=blacklister(range(len(eos_cache[wildcards.decay]["p8_ee_Zbb_ecm91"]["inclusive"]["expected_output"])), tuple_id_blacklist[wildcards.decay]["p8_ee_Zbb_ecm91"]["inclusive"])),
        inclusive_ccbar = lambda wildcards: expand(outputs+"stage1/{{decay}}/p8_ee_Zcc_ecm91/inclusive/{tuple_id}.root", tuple_id=blacklister(range(len(eos_cache[wildcards.decay]["p8_ee_Zcc_ecm91"]["inclusive"]["expected_output"])), tuple_id_blacklist[wildcards.decay]["p8_ee_Zcc_ecm91"]["inclusive"])),
        inclusive_qqbar = lambda wildcards: expand(outputs+"stage1/{{decay}}/p8_ee_Zuds_ecm91/inclusive/{tuple_id}.root", tuple_id=blacklister(range(len(eos_cache[wildcards.decay]["p8_ee_Zuds_ecm91"]["inclusive"]["expected_output"])), tuple_id_blacklist[wildcards.decay]["p8_ee_Zuds_ecm91"]["inclusive"]))
    output: outputs+"plots/mva/{decay}.png"
    log: logs+"plots/mva/{decay}.log"
    benchmark: benchmarks+"plots/mva/{decay}.txt"
    shell: "python {analysis_scripts}/mva_plot.py --inclusive_bbbar {input.inclusive_bbbar} --inclusive_ccbar {input.inclusive_ccbar} --inclusive_qqbar {input.inclusive_qqbar} --signal {input.signal} --output {output} &> {log}"

rule mva_tuples:
    input: outputs+"xgb/{decay}.root"
    output: outputs+"stage1/{decay}/{event_type}/{decay_model}/{tuple_id}.root"
    log: logs+"stage1/{decay}/{event_type}/{decay_model}/{tuple_id}.log"
    benchmark: benchmarks+"stage1/{decay}/{event_type}/{decay_model}/{tuple_id}.txt"
    run:
        desired_index = eos_cache[wildcards.decay][wildcards.event_type][wildcards.decay_model]["expected_output"].index(output[0])
        tuple_ids = eos_cache[wildcards.decay][wildcards.event_type][wildcards.decay_model]["samples"][desired_index]
        input_location = f"{MC}{wildcards.event_type}{decay_model_to_fname(wildcards.decay_model, wildcards.decay)}/events_"
        input_files = []
        for tuple_id in tuple_ids:
            input_files.append(f"{input_location}{tuple_id}.root")
        cmd = "python {analysis_scripts}stage1.py --output {output} --input {input_files} --decay {wildcards.decay} &> {log}"
        shell(cmd)

# snakemake ./output/xgb/Bd2KstNuNu.root -s ./scripts/Snakefile --latency-wait 10 --jobs 25; mv ./slurm-* ./SlurmLogs/

rule train_xgb:
    input:
        signal = lambda wildcards: blacklister([f"{input_file[:-5]}.pkl".replace("training", "pickled") for input_file in eos_cache[wildcards.decay]["p8_ee_Zbb_ecm91"]["signal"]["training_output"]], tuple_id_blacklist[wildcards.decay]["p8_ee_Zbb_ecm91"]["inclusive"]),
        inclusive_bbbar = lambda wildcards: blacklister([f"{input_file[:-5]}.pkl".replace("training", "pickled") for input_file in eos_cache[wildcards.decay]["p8_ee_Zbb_ecm91"]["inclusive"]["training_output"]], tuple_id_blacklist[wildcards.decay]["p8_ee_Zbb_ecm91"]["inclusive"]),
        inclusive_ccbar = lambda wildcards: blacklister([f"{input_file[:-5]}.pkl".replace("training", "pickled") for input_file in eos_cache[wildcards.decay]["p8_ee_Zcc_ecm91"]["inclusive"]["training_output"]], tuple_id_blacklist[wildcards.decay]["p8_ee_Zcc_ecm91"]["inclusive"]),
        inclusive_qqbar = lambda wildcards: blacklister([f"{input_file[:-5]}.pkl".replace("training", "pickled") for input_file in eos_cache[wildcards.decay]["p8_ee_Zuds_ecm91"]["inclusive"]["training_output"]], tuple_id_blacklist[wildcards.decay]["p8_ee_Zuds_ecm91"]["inclusive"])
    output: outputs+"xgb/{decay}.root"
    log: logs+"xgb/{decay}.log"
    benchmark: benchmarks+"xgb/{decay}.txt"
    shell: "python {FCCeePhysicsPerformance_scripts}/train_xgb.py --vars normal --decay {wildcards.decay} --inclusive_bbbar {input.inclusive_bbbar} --inclusive_ccbar {input.inclusive_ccbar} --inclusive_qqbar {input.inclusive_qqbar} --signal {input.signal} --output {output} &> {log}"

rule pickle:
    input: outputs+"training/{decay}/{event_type}/{decay_model}/{tuple_id}.root"
    output: outputs+"pickled/{decay}/{event_type}/{decay_model}/{tuple_id}.pkl"
    log: logs+"pickled/{decay}/{event_type}/{decay_model}/{tuple_id}.log"
    benchmark: benchmarks+"pickled/{decay}/{event_type}/{decay_model}/{tuple_id}.txt"
    shell: "python {FCCeePhysicsPerformance_scripts}/pickler.py --input {input} --output {output} &> {log}"

rule training_tuples:
    output: outputs+"training/{decay}/{event_type}/{decay_model}/{tuple_id}.root"
    log: logs+"training/{decay}/{event_type}/{decay_model}/{tuple_id}.log"
    benchmark: benchmarks+"training/{decay}/{event_type}/{decay_model}/{tuple_id}.txt"
    run:
        desired_index = eos_cache[wildcards.decay][wildcards.event_type][wildcards.decay_model]["training_output"].index(output[0])
        tuple_ids = eos_cache[wildcards.decay][wildcards.event_type][wildcards.decay_model]["training"][desired_index]
        input_location = f"{MC}{wildcards.event_type}{decay_model_to_fname(wildcards.decay_model, wildcards.decay)}/events_"
        input_files = []
        for tuple_id in tuple_ids:
            input_files.append(f"{input_location}{tuple_id}.root")
        cmd = "python {analysis_scripts}stage1.py --output {output} --input {input_files} --decay {wildcards.decay} --training &> {log}"
        shell(cmd)

# for checking efficiencies
#snakemake ./output/training/Bd2KstNuNu/p8_ee_Zbb_ecm91/signal/0.root ./output/training/Bd2KstNuNu/p8_ee_Zbb_ecm91/inclusive/0.root ./output/training/Bd2KstNuNu/p8_ee_Zcc_ecm91/inclusive/0.root ./output/training/Bd2KstNuNu/p8_ee_Zuds_ecm91/inclusive/0.root ./output/training/Bs2PhiNuNu/p8_ee_Zbb_ecm91/signal/0.root ./output/training/Bs2PhiNuNu/p8_ee_Zbb_ecm91/inclusive/0.root ./output/training/Bs2PhiNuNu/p8_ee_Zcc_ecm91/inclusive/0.root ./output/training/Bs2PhiNuNu/p8_ee_Zuds_ecm91/inclusive/0.root -s ./scripts/Snakefile --latency-wait 120 --cluster ./scripts/slurm_wrapper.py --jobs 8; mv ./slurm-* ./SlurmLogs/